# 0.2 Principios
En este capítulo, exploraremos los principios de El Estándar. Estos principios 
se aplican a todos los componentes de un sistema que cumple con El Estándar. 
Tanto si estos componentes son agentes, servicios o expositores.

## 0.2.0 Personas Primero
La idea principal de este principio es construir y diseñar sistemas conformes 
a El Estándar pensando en las personas. No sólo las personas que van a utilizar 
el sistema, sino también las que van a mantenerlo y hacerlo evolucionar.

Para que un sistema siga el principio "personas primero", debe primar la 
simplicidad sobre la complejidad. La simplicidad conduce a la reescritura. 
También lleva a diseñar sistemas monolíticos que se construyen con una 
mentalidad modular para permitir una verdadera fractalidad del patrón 
general del sistema.

El Estándar también aplica los principios de medición de los conceptos 
avanzados de ingeniería frente a la comprensión de los ingenieros 
convencionales. Los nuevos ingenieros del sector son los líderes del mañana. 
Si no aceptan cualquier sistema, acabarán por renunciar a él y lo reescribirán una y otra vez.


### 0.2.0.0 Simplicidad
El código escrito según El Estándar tiene que ser sencillo. Existen medidas 
para garantizar esta simplicidad, estas medidas son las siguientes:

#### 0.2.0.0.0 Herencia Excesiva
Cualquier software escrito de acuerdo con El Estándar no deberá tener más 
de un nivel de herencia. Más de un nivel de herencia se considerará 
excesivo y estará prohibido, excepto en los casos de versionado para el 
escalado vertical de flujos. La herencia excesiva ha demostrado a lo largo de 
los años ser una fuente de confusión y dificultad en términos de legibilidad 
y mantenibilidad.


#### 0.2.0.0.1 Entanglement

##### 0.2.0.0.1.0 Horizontal Entanglement
Building "common" components in every system with the promise to simplify the development process is another prohibited practice in Standard-compliant systems. This practice manifests itself in components with names like `Utils`, `Commons` or `Helpers`. These terminologies and what they imply in terms of false promised simplifications are not allowed. Any system built according to The Standard should be comprised of Brokers, Services, or Exposers, nothing more or less.

Another example of horizontal entanglements is shared models across multiple independent flows - sharing exceptions, validation rules, or any other form of entanglement across multiple flows.

<br />
    <div align=center>
        <img src="https://github.com/hassanhabib/The-Standard-Spanish/blob/master/0.%20Introduccion/Recursos/Principios/Principios-Horizontal.png?raw=true" />
    </div>
<br />

##### 0.2.0.0.1.1 Vertical Entanglement
This principle also applies to scenarios where base components are used. Unless these base components are native or external, they will not be allowed in a Standard-compliant system. Local base components create a vertical level of entanglement that harms the maintainability and readability of code. Vertical entanglements are just as harmful as `Commons` components, creating single points of failure across any system.

Entanglements (vertical or horizontal) also prevent engineers in any system (especially newcomers) from fully understanding the depth of the system and fully own its functionality. They also prevent engineers from having the opportunity to build end-to-end flows when half of the functionality is presumably componentized for the sake of development expedition and simplicity. 

<br />
    <div align=center>
        <img src="https://github.com/hassanhabib/The-Standard-Spanish/blob/master/0.%20Introduccion/Recursos/Principios/Principios-Vertical.png?raw=true" />
    </div>
<br />

#### 0.2.0.0.2 Autonomous Components
Every component in every system should be self-sufficient. Every component implements its own validations, tooling, and utilities in one of its dimensions with no hard dependency on any other external components except through dependency injection. This principle favors duplication over presumed simplification via code entanglement.

Autonomous components will open up the opportunity for every engineer on every team to fully own every dependency and tool their component may need to fulfill its purpose. This may cause a bit of duplication in some of the code to open an equal opportunity for every developer to learn how to build and evolve a component fully.

##### 0.2.0.0.2.0 No Magic
Autonomous components put all their routines up front, in plain sight of the engineer. No hidden routines, shared libraries, or magical extensions that require chasing references once an inevitable split of the big monolith begins to occur.

We will treat Objects the way they are in nature: multi-dimensional components self-containerized like atoms in nature. These components perform their own validations, exception handling, tracing, security, localization, and everything else.

<br />
	<div align=center>
		<img src="https://github.com/hassanhabib/The-Standard-Spanish/blob/master/0.%20Introduccion/Recursos/Principios/Principios.png?raw=true" />
	</div>
<br />

Components built according to The Standard strictly adhere to the idea of _What You See Is What You Get_ (WYSIWYG) - everything concerning the components will be on the component itself.

## 0.2.1 Rewritability
Every system should be developed with the rewritability principle in mind. The principle dictates that our assumptions in the systems we develop have the high potential of being reexamined and probably reconsidered. Every system should be easily rewritable as a measure of adherence to forever growing and changing business requirements.

Rewritable code is code that is easy to understand, modify and fully rewrite. Rewritable code is extremely modular and autonomous; it encourages engineers to evolve it with the least effort and risk possible.

Rewritable code doesn't play tricks on the reader. It should be plug-n-play - fork, clone, build and run all its tests successfully with no issues. There are no hidden dependencies, injected routines at runtime, nor unknown prerequisites. 

## 0.2.2 Mono-Micro
Build monolithic systems with a modular mindset, with every flow fully independent from other flows. For instance, we may build a monolithic system with a microservice mindset, meaning that any flow can be extracted out of the system and turned into its own microservice or lambda with the least effort possible.

This principle goes hand in hand with the concept of autonomous components at a higher level where flows are also autonomous from their neighboring flow and their hosting system.

## 0.2.3 Level 0
Code must be understandable by an entry-level individual in the engineering craft. The majority of engineers in our industry will always be those who are new to the craft. Our code base continues to live on based on how easy it is to understand by most engineers in the industry.

Level 0 engineers are our measure of success. Their ability to understand our code is our reassurance that this very code will continue to live and evolve with the next generation of engineers.

This principle also mandates that every engineer in the industry closely examine their code and pair with juniors in the field to see if they meet this principle.

## 0.2.4 Open Code
Open code as a principle dictates that everything written according to The Standard should be commonly available to the public. This applies to internal architectural practices, trial libraries, and any other form of module development that doesn't allow every engineer to learn and evolve any given system. Developing internal tools that are not accessible shall inevitably harm the engineering experience for those who are trying to evolve these very tools.

The principle also recognizes that under extreme circumstances, such as when safety or security are threatened, or under some contractual obligation, one cannot make code, tooling, platforms, and patterns available to the public. However, making the source proprietary solely for personal or organizational gain is not permitted by The Standard.

## 0.2.5 Airplane Mode (Cloud-Foreign)
The Standard enforces the idea of airplane mode. Where engineers can stand up their entire infrastructure on their local machine without needing or having any network connection, this principle goes heavily against principles such as Cloud-Native applications, where a given system cannot stand and run without cloud infrastructure.

The Standard also encourages its adopters to develop the proper tooling to bridge the gap between cloud infrastructural components and local components such as queues, event hubs, and other tools to make it easily testable and modifiable.

## 0.2.6 No Toasters
The Standard shall be taught man to man, not machine to man. No stylecops or analyzers should be implemented to force people into following The Standard. It should be driven by passion in the heart and conviction in the mind. The Standard should be taught by people to people. It's meant to foster an engineering culture of open discussions, conviction and understanding.

## 0.2.7 Pass Forward
The Standard shall be taught at no cost as it arrived to you at no cost. It should be passed forward to the next engineer also at no cost, regardless of their financial, social, or educational status. The Standard is pure knowledge given by the selfless to the selfless. There shall be no profiteering off of it; neither shall it be a reason for someone to belittle others or make them feel less. Teaching The Standard for profit violates it and denies the beneficiary (the violator) any further guidance from The Author.
