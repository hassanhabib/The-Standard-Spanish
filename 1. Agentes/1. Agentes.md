# 1 Agentes

## 1.0 Introducción
Los agentes son un enlace entre la lógica de negocio y el mundo exterior.
Son envoltorios alrededor de bibliotecas externas, recursos, servicios o APIs con el fin de satisfacer un interfaz local para que el negocio pueda interaccionar con el exterior sin tener que estar estrechamente acoplado con cualquiera de los recursos o implementaciones de librerías externas.

Los agentes, en general, están pensados para ser desechables y 
reemplazables - son construidos teniendo en cuenta que la tecnología 
evoluciona y cambia constantemente y, por lo tanto, en algún momento del 
ciclo de vida de una determinada aplicación serán sustituidos por una 
tecnología más nueva que haga el trabajo más rápido.

Pero los Agentes también garantizan que su negocio sea integrable al 
abstraer cualquier dependencia específica de recursos externos de lo que su 
software esté tratando de realizar realmente.

Por ejemplo, digamos que tiene un API que fue construido para consumir y 
proporcionar datos de un servidor SQL. En algún momento, decidió que una 
opción mejor y más económica para su API es confiar en una tecnología 
NoSql en su lugar.
Disponer de un agente para abstraer la dependencia de SQL hará mucho más 
fácil la integración con NoSql en el menor tiempo y coste humanamente 
posible.

## 1.1 Sobre el Mapa
En cualquiera aplicación, móvil, escritorio, web o simplemente un API, los agentes usualmente residen al final de cualquier aplicación puesto que son el último punto de contacto entre nuestro código personalizado y el mundo exterior.

Ya sea que el mundo exterior en este caso sea simplemente un 
almacenamiento local en la memoria, o un sistema totalmente independiente 
que reside detrás de una API, todos ellos tienen que residir detrás de los 
Brokers sea cual sea la aplicación.

En la siguiente arquitectura de bajo nivel para una determinada API - Los 
agentes residen entre nuestra lógica de negocio y el recurso externo:


<br />
    <p align=center>
        <img src="https://github.com/hassanhabib/The-Standard-Spanish/blob/main/1.%20Agentes/Recursos/Agentes-1.0.0.png?raw=true" />
    </p>
<br />

## 1.2 Características
Hay unas pocas y simples reglas que rigen la implementación de cualquier agente - estas reglas son:

### 1.2.0 Implementan un interfaz local
Los Agentes deben satisfacer un contrato local. Deben implementar un interfaz local para permitir el desaclopamiento entre la implementación y los servicios que consumen dichos agentes.

Por ejemplo, dado que tenemos un contrato local `IAgenteAlmacenamiento` que requiere una implementación para cualquier operación CRUD para un modelo local `Estudiante` - la operación del contrato debiera ser de la siguiente manera:

```csharp
    public partial interface IAgenteAlmacenamiento
    {
        IQueryable<Estudiante> SeleccionaTodosEstudiantes();
    }
```

Una implementación para un agente de almacenamiento debiera ser de la siguiente manera:

```csharp
    public partial class AgenteAlmacenamiento
    {
        public DbSet<Estudiante> Estudiantes { get; set; }

        public IQueryable<Estudiante> SeleccionaTodosEstudiantes()
        {
            using var agente = new AgenteAlmacenamiento(this.configuracion);

            return agente.Estudiantes;
        }
    }
```
Una implementación de un contrato local puede ser reemplazo en cualquier momento, desde la utilización de Entity Framework como fue mostrado en el ejemplo anterior hasta la utilización de tecnología completamente diferente como Dapper or una infraestructura completamente diferente como bases de datos Oracle o PostgreSQL.

### 1.2.1 Sin Control de Flujo
Los Agentes Brokers no deberían tener forma alguna de control de flujo tales como if, while-loops, o casos switch - Esto es porque el control de flujo es considerado a ser lógica de negocio, y ello encaja mejor en la capa de servicios donde la lógica de negocio debiera estar, y no en los Agentes.

Por ejemplo, un método de agente que recupera una lista de estudiantes desde la base de datos se asemejaría algo así:

```csharp
    public IQueryable<Estudiante> SeleccionaTodosEstudiantes() => SeleccionaTodos<Estudiante>();
```
Un función simple que llama al nativo `DbSet<T>` de Entity Framework y devuelve un modelo local como `Estudiante`.


### 1.2.2 Sin Manejo de Excepciones
El manejo de excepciones es una manera de control de flujo. Los Agentes no son concebidos en el manejo de cualquier excepción pero sí que debe permitir que la excepción sea propagada hacia los servicios vecinos del agente, donde estas excepciones puede ser mapeadas y localizadas adecuadamente.


### 1.2.3 Propietario de sus Propias Configuraciones
Agente también requieren manejar sus configuraciones - pueden tener un inyección de dependencias a partir de un objeto de configuración con el fin de recuperar y establecer las configuraciones para cualquier recurso externo que estén integrando.

Por ejemplo, las cadenas de conexión involucradas con las comunicaciones de base de datos son requeridas para ser recuperadas y establecidas en el cliente de base de datos para poder realizar una conexión satisfactoriamente, de la manera que sigue:

```csharp
    public partial class AgenteAlmacenamiento : EFxceptionsContext, IAgenteAlmacenamiento
    {
        private readonly IConfiguration configuracion;

        public AgenteAlmacenamiento(IConfiguration configuracion)
        {
            this.configuration = configuration;
            this.Database.Migrate();
        }

        ...
        ...

        protected override void OnConfiguring(DbContextOptionsBuilder constructorOpciones)
        {
            constructorOpciones.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
            string cadenaConexion = this.configuracion.GetConnectionString("ConexionPorDefecto");
            constructorOpciones.UseSqlServer(cadenaConexion);
        }
    }
```

### 1.2.4 Nativos desde Primitivos
Agentes pueden construir un objeto para un modelo externo basado en tipos primitivos pasados desde los servicios próximos al agente.

Por ejemplo, en un agente de notificación de correos electrónicos, los parámetros de entrada para una función `.Envia(...)` requiere de parámetros de entrada básicos como son el asunto, contenido, or dirección. Aquí un ejemplo:

```csharp
    public async ValueTask EnviaCorreoAsync(List<string> destinatarios, string asunto, string contenido)
    {
        Mensaje mensaje = ConstruyeMensaje(destinatarios, destinatariosConCopia, asunto, contenido);
        await EnviaMensajeCorreoAsync(mensaje);
    }
```

Los parámetros de entrada primitivos asegurarán que no hay fuertes dependencias entre los servicios próximos al agente y los modelos externos.
Incluso en situaciones donde el agente es simplemente un punto integración entre la aplicación y un API RESTful externo, es altamente recomendable construir los modelos nativos para que reflejen el mismo objeto JSON enviado y devuelto desde el API en vez confiar en bibliotecas NuGet, DLLs o proyectos compartidos para conseguir el mismo objetivo.

### 1.2.5 Convenciones de Nomenclatura
Los contratos para los agentes permanecerán tan genéricos como sea posible para indicar la funcionalidad general de un agente; por ejemplo, decimos `IAgenteAlmacenamiento` en vez de `IAgenteAlmacenamientoSql` para indicar una tecnología particular o infraestructura.

Con un único agente de almacenamiento, puede ser más conveniente mantener el mismo nombre como contrato. Pero en caso de implementaciones concretas de agentes, todo depende de cuantos agentes existan para proporcionar funcionalidad parecida. En nuestro caso, tenemos uns implementación concreta de `IAgenteAlmacenamiento`, así que el nombre sería `AgenteAlmacenamiento`.

Sin embargo, si la aplicación soporta múltiples colas, almacenamientos, o proveedores de servicios de correo electrónico, quizás sea necesario empezar a especificar el objetivo general en el componente; por ejemplo, un `IAgenteCola` tendría múltiples implementación como `AgenteColaNotificacion` y `AgenteColaPedidos`.

Pero si la implementación concreta apunta al mismo modelo y lógica de negocio, entonces un desvío hacia la tecnología podría ser lo más apropiado. En este caso, por ejemplo, `IAgenteAlmacenamiento`, dos implementaciones concretas diferentes podrían ser `AgenteAlmacenamientoSQL` y `AgenteAlmacenamientoMongo`. Este caso es típico en situaciones donde la intención es reducir los costes de infraestructura de producción.

### 1.2.6 Nomenclatura
Agentes hablan el lenguaje de las tecnologías que soportan.
Por ejemplo, en un agente de almacenamiento, decimos `SeleccionaPorId` para coincidir con una sentencia SQL `Select`, y en un agente de cola, decimos `Encola` para hacer coincidir el lenguaje.

Si un agente está integrando un endpoint de un API, entonces seguirá la semántica RESTFul, como son `Envia` (`POST`), `Obtiene` (`GET`) or `Pon` (`PUT`). Aquí un ejemplo:

```csharp

    public async ValueTask<Estudiante> EnviaEstudianteAsync(Estudiante estudiante) =>
        await this.EnviaAsync(UrlRelativa, estudiante);

```

### 1.2.7 Hacia Arriba y de Lado
Los agentes no pueden llamar a otros agentes; porque los agentes son el primer punto de abstracción, no requieren abstracciones adicionales o otras dependencias más que el acceso al modelo de configuración.

Los agentes tampoco pueden tener servicios como dependencias ya que el flujo en cualquier sistema vendrá desde los servicios hacia los agentes y no de otra manera.

Por ejemplo, incluso cuando un microservicio tiene una suscripción a una cola, los agente pasarán hacia delante un método escuchador para procesar los eventos entrantes pero no llamarán a los servicios para proporcionar la lógica de procesamiento.

La regla general aquí entonces sería que los servicios sólo pueden llamar a los agentes, mientras que los agentes sólo pueden llamar a dependencias nativas externas.

## 1.3 Organización
Los agentes que soportan múltiples entidades, como son los agentes de almacenamiento, deben aprovecharse de las clases parciales para partir las responsabilidades por entidad.

Por ejemplo, si tenemos un agente de almacenamiento que proporciona todas las operaciones CRUD para ambos modelos `Estudiante` y `Profesor`, la organización de los ficheros sería como sigue:

- IAgenteAlmacenamiento.cs
  - IAgenteAlmacenamiento.Estudiantes.cs
  - IAgenteAlmacenamiento.Profesores.cs
- AgenteAlmacenamiento.cs
  - AgenteAlmacenamiento.Estudiantes.cs
  - AgenteAlmacenamiento.Profesores.cs

El propósito principal de esta organización particular, aprovechar las clases parciales, está en la separación de las responsabilidades para cada entidad a un nivel más fino, en cual proporcionará una mayor mantenibilidad del software.


Las convenciones de nomenclatura de archivos y carpetas se centran estrictamente en la pluralidad de las entidades que soportan y la singularidad para el recurso general soportado.

Por ejemplo, decimos `IAgenteAlmacenamiento.Estudiantes.cs`. Y también decimos `IAgenteCorreoElectronico` or `IAgenteCola.Notificaciones.cs` - singular para el recurso y plurarl para las entidades.

El mismo concepto aplica para las carpetas o los espacios de nombres que contienen a los agentes.

Por ejemplo, decimos:

```csharp
namespace OtripleS.Web.Api.Agentes.Almacenamientos
{
    ...
}
```

Y decimos:
```csharp
namespace OtripleS.Web.Api.Agentes.Colas
{
    ...
}
```

## 1.4 Tipos de Agentes
En la mayoría de las aplicaciones construidas a día de doy, algunos agentes comunes son usualmente necesitados para conseguir que una aplicación empresarial arranque y se ejecute - algunos de estos son Almacenamiento, Horario, APIs, Trazador y Colas.

Algunos agentes interaccionan con recursos existentes en el sistema, como el *tiempo* para permitir a los servicios vecinos al agente
tratar al *tiempo* como una dependencia y controlar como un servicio particular se comportaría en base al valor de tiempo en cualquier punto del pasado, presente o del futuro.

### 1.4.0 Agentes de Entidad
Los agente de entidad proporcionan puntos de integración con recursos externos que el sistema necesita para satisfacer requerimientos de negocio.

Por ejemplo, los agente de entidad se integran con el almacenamiento, proporcionando capacidad de almacenamiento o recuperación de registros de la base de datos.

Los agentes de entidad también son como agentes de cola, proporcionando un punto de integración para colocar mensajes en una cola para que otros servicios consuman y satisfagan el procesamiento de su lógica de negocio.

Los servicios vecinos de un agente sólo puden llamar a agentes de entidades por que requieren un nivel de validación de la información que reciben o proporcionan antes de poder continuar.

### 1.4.1 Agentes de Soporte
Los agentes de soporte son agentes de propósito general, proporcionan la funcionalidad para apoyar a los servicios, pero no tienen características que los hagan diferentes de otro sistema.

Un buen exemplo de agente de soporte es el `AgenteHorario` - un agente concebido específicamente para abstraer de la capa de negocio la fuerte dependencia sobre la fecha y hora del sistema.

Los agentes horarios no apuntan hacia ninguna entidad específica, y el son prácticamente iguales en todos los sistemas.

Otro ejemplo de agentes de soporte es el `AgenteTrazador` - proporcionan información para trazar y monitorizar sistemas proporcionando a los ingenieros visualizar el flujo general de la información a través del sistema y ser notificados en caso de la existencia de algún problema.

Los agentes de soporte pueden ser llamados a través de la completa capa de negocio: sobre servicios fundamentales, de procesamiento, de orquestación, de coordinación, de gestión, o de agreación, no como los agentes de entidad. Esto es por qué los agente trazadores son requeridos como un componente de apoyo al sistema para proporcionar todas las capacidades necesitadas por los servicios para trazar sus errores o calcular una fecha o cualquier otra funcionalidad de apoyo.

Puedes encontrar ejemplos reales de agentes en el proyecto OtripleS [aquí](https://github.com/hassanhabib/OtripleS/tree/master/OtripleS.Web.Api/Brokers).

## 1.5 Implementación
Aquí una implmentación real de un agente de almacenamiento completo para todas las operaciones CRUD de la entidad `Estudiante`:

###### Para IAgenteAlmacenamiento.cs:
```csharp
namespace OtripleS.Web.Api.Agentes.Almacenamientos
{
    public partial interface IAgenteAlmacenamiento
    {
    }
}

```

###### For AgenteAlmacenamiento.cs:
```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using EFxceptions.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using OtripleS.Web.Api.Models.Users;

namespace OtripleS.Web.Api.Agentes.Almacenamientos
{
    public partial class AgenteAlmacenamiento : EFxceptionsIdentityContext<User, Role, Guid>, IAgenteAlmacenamiento
    {
        private readonly IConfiguration configuracion;

        public AgenteAlmacenamiento(IConfiguration configuracion)
        {
            this.configuracion = configuracion;
            this.Database.Migrate();
        }

        private async ValueTask<T> InsertaAsync<T>(T entidad)
        {
            this.Entry(entidad).State = EntityState.Added;
            await this.SaveChangesAsync();

            return entidad;
        }

        private IQueryable<T> SeleccionaAll<T>() where T : class => this.Set<T>();

        private async ValueTask<T> SeleccionaAsync<T>(params object[] @objectIds) where T : class =>
            await this.FindAsync<T>(objectIds);

        private async ValueTask<T> ActualizaAsync<T>(T entidad)
        {
            this.Entry(entidad).State = EntityState.Modified;
            await this.SaveChangesAsync();

            return entidad;
        }

        private async ValueTask<T> EliminaAsync<T>(T entidad)
        {
            this.Entry(entidad).State = EntityState.Deleted;
            await this.SaveChangesAsync();

            return entidad;
        }

        ...

        protected override void OnConfiguring(DbContextOptionsBuilder constructorOpciones)
        {
            constructorOpciones.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
            string cadenaConexion = this.configuracion.GetConnectionString("ConexionPorDefecto");
            constructorOpciones.UseSqlServer(cadenaConexion);
        }
    }
}
```

###### For IAgenteAlmacenamiento.Estudiantes.cs:
```csharp
using system;
using system.Linq;
using system.Threading.Tasks;
using OtripleS.Web.Api.Modelos.Estudiantes;

namespace OtripleS.Web.Api.Agentes.Almacenamientos
{
    public partial interface IAgenteAlmacenamiento
    {
        public ValueTask<Estudiante> InsertaEstudianteAsync(Estudiante estudiante);
        public IQueryable<Estudiante> SeleccionaTodosEstudiantes();
        public ValueTask<Estudiante> SeleccionaEstudiantePorIdAsync(Guid idEstudiante);
        public ValueTask<Estudiante> ActualizaEstudianteAsync(Estudiante estudiante);
        public ValueTask<Estudiante> EliminaEstudianteAsync(Estudiante estudiante);
    }
}
``` 

###### For StorageBroker.Estudiantes.cs:
```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using OtripleS.Web.Api.Modelos.Estudiantes;

namespace OtripleS.Web.Api.Agentes.Almacenamientos
{
    public partial class AgenteAlmacenamiento
    {
        public DbSet<Estudiante> Estudiantes { get; set; }

        public async ValueTask<Estudiante> InsertaEstudianteAsync(Estudiante estudiante) =>
            await InsertaAsync(estudiante);

        public IQueryable<Estudiante> SeleccionaTodosEstudiantes() => SeleccionaTodos<Estudiante>();

        public async ValueTask<Estudiante> SeleccionaEstudiantePorIdAsync(Guid idEstudiante) =>
            await SeleccionaAsync<Estudiante>(idEstudiante);

        public async ValueTask<Estudiante> ActualizaEstudianteAsync(Estudiante estudiante) =>
            await ActualizaAsync(estudiante);

        public async ValueTask<Estudiante> EliminaEstudianteAsync(Estudiante estudiante) =>
            await EliminaAsync(estudiante);
    }
}
```

## 1.6 Resumen
Los agentes son la primer capa de abstracción entre la lógica de negocio y el mundo exterior. Pero no son la única capa de abstracción; por que tódavía habrá unos pocos modelos nativos que se filtran a través de los agentes hacia los servicios vecinos a los agentes. Es natural evitar realizar mapeos fuera del reino de la lógica; en nuestro caso, aquí, los servicios fundamentales.

Por ejemplo, en un agente de almacenamiento, sin importar el ORM usado, algunas excepciones nativas del ORM (Entity Framework por ejemplo) ocurrirán, como una `DbUpdateException` o `SqlException`. En este caso, necesitamos otra capa de abstracción para jugar el papel de mapeador entre estas excepciones y nuestra lógica de núcleo para poder convertilas en modelos de excepción locales.

Esta responsabilidad está en manos de los servicios vecinos al agente. Yo los denomino servicios fundamentales, estos servicios son el último punto de abstracción antes de la lógica de núcleo que consiste de modelos y contratos locales.


## 1.7 Preguntas Frecuentes

A lo largo del tiempo, algunas preguntas comunes surgen de los ingenieros con los que trabajé a lo largo de mi carrera. Desde que algunas de estas preguntas son recurrentes en bastantes casos, pensé que puede ser de ayuda añadirlas aquí para todos con el fin de aprender sobre otras perspectivas acerca de los agentes.

#### 1.7.0 ¿Es el Patrón de los Agentes lo mismo que el Patrón Repositorio?
No exactamente, al menos desde un punto de vista operacional, los agentes parecen ser más genéricos que los repositorios.

Los repositorios usualmente están orientados a operaciones parecidas a los almacenamientos, principalmente en los casos de bases de datos. Pero los agentes pueden ser un punto de integración con cualquier dependencia externa como los servicios de correo electrónico, colas y otros APIs.

Un patrón más similar a los agentes es el patrón de unidad de trabajo (Unit of Work). Principalmente se centra en las operaciones generales sin tener en cuenta la definición o el nombre con una operación particular.

Todos estos patrones, en general, intentan implementar el mismo principio SOLID: separación de responsabilidad, inyección de dependencias y responsabilidad única.

Pero puesto que SOLID son principios y no líneas guía exactamente, se espera ver toda clase de implementaciones diferentes y patrones para conseguir este principio.

#### 1.7.1 ¿Por qué los agentes no puede implementar un contrato para métodos que devuelven un interfaz en vez de un modelo concreto?
Esto sería una situación ideal, pero esto también requeriría a los agentes realizar una conversión o mapeo entre los modelos nativos devueltos desde recursos externos de SDKs y el modelo interno que se corresponde con el contrato local.

Realizar esto a nivel de agente requerirá incluir lógica de negocio en este reino, lo que está completamente fuera del alcance de propósito del componente.

Definimos código de lógica de negocio como cualquier intencionalidad de código secuencial, selectivo o de iteración. Los agentes no realizan pruebas unitarias por que no tienen lógica de negocio. Serán parte de pruebas de aceptación o integración pero no formarán parte de los test unitarios - simplemente por que no contienen lógica de negocio dentro de ellos.

#### 1.7.2 Si los agentes fueran una capa de abstracción de la lógica de negocio, ¿Por qué permitimos que las excepciones se filtren a través de ellos hacia la capa de servicios?
Los agentes solo son la *primera* capa de abstracción, pero será la única. Los servicio vecinos al agente son responsables de la conversión de las excepciones nativas producidas en un agente en un modelo de excepción local que puedan ser manejadas y procesadas internamente dentro del reino de la lógica de negocio.

La lógica de negocio emerge en las capas deprocesamiento, orquestación, coordinación y agregación donde todas las excepciones, todos los modelos devueltos y todas las operaciones son locales al sistema.

#### 1.7.3 ¿Por qué usamos clases parciales en los agentes que manejan múltiples entidades?
Ya que los agentes deben ser propietarios de sus propias configuraciones, tiene más sentido la parcialización cuando sea posible para evitar reconfiguraciones en cada agente de almacenamiento de cada entidad.

Las clases parciales son una característica en el lenguaje C#, pero deberá ser posible implementar el mismo comportamiento a través de la herencia en otro lenguaje de programación.

#### 1.7.4 ¿Son los agentes lo mismo que los proveedores (Patrón Proveedor)?
No. Proveedores emborronan la línea entre los servicios (lógica de negocio) y los agentes (capa de integración) - los agentes están enfocados como componentes particulares dentro del sistema que son desechables. Proveedores parece incluir más que eso.


[*] [Implementando Componentes Abstractos (Agentes)](https://www.youtube.com/watch?v=6NlgSskQXSo)

[*] [Implementando Componentes Abstractos (Agentes)](https://www.youtube.com/watch?v=d1cqEKMBmno)

[*] [Generando Migraciones de Modelo con EntityFramework](https://www.youtube.com/watch?v=6sD5zz9BuOk)
