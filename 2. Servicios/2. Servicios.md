# 2 Servicios

## 2.0 Introducción

Los servicios, en general, son los contenedores de toda la lógica de negocio en cualquier software - es el componente central de cualquier sistema y el principal componente que hace un sistema diferente de otro.

Nuestro principal objetivo con los servicios es mantenerlos agnósticos de tecnologías específicas o dependencias externas.

Cualquier capa de negocio es más compatible con El Estándar si puede ser integrado con otras dependencias y tecnologías de exposición con el mínima cantidad de esfuerzo integrador.

### 2.0.0 Operaciones de Servicios

Cuando hablamos de lógica de negocio, principalmente nos referimos a 3 principales categorías de operaciones: validación, procesamiento e integración.

<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100530065-4494d680-31a2-11eb-8393-32b21ab99a3d.png" />
</p>
<br />

Hablemos de estas categorías.

#### 2.0.0.0 Validaciones

Las validaciones aseguran que la información entrante y saliente cumple una particular serie de reglas: estructurales, lógicas, o validaciones externas, en este orden exacto de prioridad. Profundizaremos en los detalles sobre esto en las siguientes secciones.

#### 2.0.0.1 Procesamiento

Procesamiento se centra principalmente sobre el control de flujo, mapeo y computación para satisfacer una necesidad de negocio - las operaciones de procesamiento distinguen un servicio de otro y, en general, una aplicación de otra.

#### 2.0.0.2 Integración

Finalmente, el proceso de integración se centra en la recuperación y establecimiento de información desde o hacia cualquier dependencia de los sistemas integrados.

Hablaremos sobre estos aspectos en detalle en el siguiente capítulo. Lo principal a entender sobre los servicios es que el diseño debe ser encufable y configurable para integrar fácilmente con cualquier tecnología desde un punto de vista de dependencia y fácil de conectar a cualquier funcionalidad de exposición desde un punto de vista de API.

### 2.0.1 Tipos de Servicios

Los servicios pueden ser de diferentes tipos en función de su disposición a la arquitectura tratada. Todos pueden ser clasificados en una de estas 3 categorías: validadores, orquestadores o agregadores.

<br />
<p align=center>
 <img src="https://user-images.githubusercontent.com/1453985/100529444-b23e0400-319c-11eb-816a-59c73154542b.png" />
</p>
<br />

#### 2.0.1.0 Validadores

Los servicios de validación son principalmente servicios vecinos a los agentes o a los servicios fundamentales.

Las responsabilidad principal de estos servicios es añadir una capa de validación por encima de las operaciones primitivas existentes, como son las operaciones CRUD, para asegurar que la información entrante y saliente es validada estructural, lógica y externamente antes de enviar la información hacia dentro o fuera de un sistema.

#### 2.0.1.1 Orquestadores

Los servicios de orquestación son el núcleo de una capa de lógica de negocio. Pueden ser servicios procesadores, orquestadores, coordinadores o gestores, dependiendo del tipo de sus dependencias.

Los servicios de orquestación principalmente se centran en la combinación de múltiples operaciones primitivas o múltiples lógicas de negocio de orden superior para conseguir un objetivo aún más superior.

Los servicios de orquestación son los que toman decisiones dentro de una arquitectura, son los propietarios del flujo de control de cualquier sistema, y el principal componente que hace que una aplicación sea diferente de otra.

Intencionadamente diseñamos los Servicios de Orquestación para que vivan más tiempo que cualquier otro tipo de servicio en el sistema.

#### 2.0.1.2 Agregadores

La principal responsabilidad de los servicios de agregación es unir los resultados de múltiples servicios de procesamiento, orquestación, coordinación o gestión para exponer un único API para el controlador del API o componente del interfaz de usuario tratado para interactuar con el resto del sistema.

Los agregadores son los guardianes de la capa de la lógica de negocio. Aseguran que los componentes de exposición de información (como los controladores API) están interactuando con un sólo punto de contacto para interactuar con el resto del sistema.

Los agregadores, en general, no se preocupan por el orden de llamada entre operaciones que están enlazadas dentro de ellos. Aún así, a veces es necesario ejecutar alguna operación, como es la creación de un registro de estudiante antes de ser asignada su tarjeta de biblioteca.

En los siguientes capítulos, hablaremos sobre cada uno de estos tipos de servicios.

### 2.0.2 Reglas Generales

Varias reglas gobiernan la arquitectura general y diseño de servicios en cualquier sistema.

Estas reglas garantizan la lectura, mantenibilidad y configurabilidad del sistema por completo - en cualquier orden particular.

#### 2.0.2.0 Realiza o Delega

Cada servicio debe realizar o delegar el trabajo pero no ambos.

Por ejemplo, un servicio de procesamiento debe delegar el trabajo de persistencia de información hacia un servicio fundamental y no intentar realizar el trabajo por sí mismo.

#### 2.0.2.1 Dos-Tres (Patrón Florance)

Para los servicios de orquestación, sus dependencias sobre los servicios (no agentes) deben estar limitadas a dos o tres, pero ni a uno ni a cuatro ni más.

Si un Orquestador depende sólo de un servicio, entonces infringe la definición de orquestación que es la combinación de múltiples operaciones de diferentes orígenes para conseguir una lógica de negocio de orden superior.

###### Este patrón viola el Patrón Florance

<br/>
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100561648-4926c100-326e-11eb-9028-96bcd3eb0b1d.png">
</p>
<br />

###### Este patrón sigue la simetría del Patrón Florance

<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100561978-2a74fa00-326f-11eb-9d05-404eed3eaf5f.png">
</p>
<br />

El patrón Florance también garantiza el balance y la simetría de la arquitectura general.

Por ejemplo, no podemos orquestrar entre un servicio fundamental y de procesamiento. Ello causa una forma de desequilibrio en la arquitectura y dificulta cuando intentamos combinar una declaración unificada con el lenguaje que cada servicio especifica en base a su nivel y tipo.

Los agregadores son los únicos tipos de servicios que permiten que esta regla sea infringida, donde la combinación y el orden de los servicios o sus llamadas no tengan un impacto real.

Hablaremos en detalle sobre el patrón Florance en las siguientes secciones de El Estándar.

#### 2.0.2.2 Único Punto de Exposición

Controladores API, componentes de Interfaz de Usuario u otra forma de exposición de información de un sistema debe tener un único punto de contacto con la capa de lógica de negocio.

Por ejemplo, un endpoint API que proporciona endpoints para persistir y recuperar información de un estudiante no debiera tener múltiples integraciones con múltiples servicios pero sí un servicio que proporciona todas estas características.

A veces, un único servicio de orquestación, coordinación o gestión no proporciona todo lo relativo a una entidad particular. Un servicio de agregación combina todas estar características en un única servicio preparado para ser integrado con una tecnología de exposición.

#### 2.0.2.3 Mismo Modelo o Modelo Primitivo para Entrada/Salida

Todos los servicios deben mantener un único contrato respecto sus tipos de entrada y salida, excepcto si son primitivos.

Por ejemplo, un servicio que proporciona operaciones para un tipo de entidad Estudiante - no debería devolver desde cualquiera de sus métodos cualquier otro tipo de entidad.

Podriamos devolver una agregación de la misma entidad ya sea un modelo personalizado o nativo como son List<Estudiante> o EstudiantesAgregados, o un tipo primitivo para obtener la cuenta de los estudiantes, o un boolean indicando ya sea si un estudiante existe o no pero no un contrato que no sea ni primitivo ni no agregado.

Una regla similar aplica para los parámetros de entrada - cualquier servicio puede recibir un parámetro de entrada para el mismo contrato, un contrato de agregación virtual o un tipo primitivo pero no cualquier otro contrato.

Esta regla se centra en la responsabilidad de un servicio sobre una única entidad y sus operaciones relacionadas.

Cuando un servicio devuelve un contrato diferente, infringe su convención de nomenclatura como ServicioOrquestacionEstudiante devolviendo una List<Profesor> - y comienza a producirse la trampa de ser llamado por otros servicios desde un flujo de información completamente diferente.

Para los parámetros de entrada primitivos, si pertenecen a un modelo de entidad diferente que no es necesaria una referencia a la entidad primaria, plantea la cuestión de orquestrar entre dos servicios de procesamiento o fundamentales para mantener un modelo unificado sin romper la regla de contrato puro.

Supón que sea requerida la combinación de diferentes contratos múltiples. En ese caso, un nuevo modelo unificado indica la necesidad para un nuevo contrato unificado para el servicio de orquestación con implementación de mapeados relativo al nivel concreto de ese servicio para mantener garantía de compatibilidad e integración.

#### 2.0.2.4 Cada Servicio Para Sí Mismo

Cada servicio es responsable de la validación de sus entradas y sus salidas. No confian en servicios por encima o por debajo para validar la información.

Esto es un mecanismo de programación defensiva para garantizar que en caso de intercambiar implementaciones por detrás de los contratos, la responsabilidad de cualquier servicio dado no se vea afectado si cualquiera de los servicios por encima o por debajo decidan pasar sobre sus validaciones sea cual sea la causa.

Dentro de cualquier sistema basado en una arquitectura monolítica, de microservicios o sin servidor, cada servicio está diseñado para que pueda separarse del sistema en algún momento y convertirse en el último punto de contacto antes de integrarse con algún agente de recursos externo.

Por ejemplo, en la siguiente arquitectura, los servicios mapean partes de un modelo de entrada Estudiante en un modelo TarjetaBibliteca. He aquí una representación de los modelos:

###### Estudiante

```csharp
public class Estudiante
{
    public Guid Id {get; set;}
    public string Nombre {get; set;}
}
```

###### TarjetaBiblioteca

```csharp
public class TarjetaBiblioteca
{
    public Guid Id {get; set;}
    public Guid IdEstudiante {get; set;}
}
```

Ahora, asume que nuestro servicio de orquestación `ServicioOrquestacionEstudiante` está garantizando que cada nuevo estudiante que consiga registrarse necesitará que tenga una tarjeta de biblioteca, así nuestra lógica podría ser como sigue:

```csharp
public async ValueTask<Estudiante> RegistraEstudianteAsync(Estudiante estudiante)
{
    Estudiante estudianteRegistrado =
        await this.servicioProcesamientoEstudiante.RegistraEstudiante(estudiante);

    await AsignaTarjetaBibliotecaAEstudianteAsync(estudiante);

    return estudianteRegistrado;
}

private async ValueTask<TarjetaBiblioteca> AsignaTarjetaBibliotecaAEstudianteAsync(Estudiante estudiante)
{
    TarjetaBiblioteca tarjetaBibliotecaEstudiante = MapeaATarjetaBiblioteca(estudiante);

    return await this.servicioProcesamientoTarjetaBiblioteca.AñadeTarjetaBibliotecaAsync(tarjetaBibliotecaEstudiante);
}

private TarjetaBiblioteca MapeaATarjetaBiblioteca(Estudiante estudiante)
{
    return new TarjetaBiblioteca
    {
        Id = Guid.NewGuid(),
        IdEstudiante = estudiante.Id
    };
}
```

Como vimos arriba, un id de estudiante válido es requerido para garantizar a su vez un mapeo satisfactorio de TarjetaBiblioteca - y así como el mapeado es una responsabilidad del orquestador, requerimos garantizar que el estudiante de entrada y su id sean correctos antes de proceder con el proceso de orquestación.
